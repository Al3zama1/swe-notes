# Keys
Keys are the primary way to access data values within redis. They are unique and are binary safe. This means any binary sequence can be used as a key, anything from a simple string like "Foo", numbers like 42, or 3.1415, or a binary value.
* Keys can be up to 512 MB in size, but that number can change in the future.
* Super long keys are generally not recommended.
* There is a trade-off between having reasonable key names versus the amount of memory used to store them.

# Key Space

* Logical Database
* Flat key space
* No automatic namespacing
* Naming conventions

Redis does not have the concept of databases, but uses the term as a type of name-spacing. Within a logical database, a single flat key space exists. This means all key names occupy the same space and there is no automatic separation of key names into named groups such as buckets or collections.

A logical database is identified by a zero-based index. The default is database 0. Within a logical database, all keys are unique. However, the same key name can appear in multiple logical databases because they provide separation of key names.

Logical databases are best suited when you need separate key spaces for a single application rather than separating multiple applications.

Logical databases have a number of restrictions. Notably, Redis cluster only supports database 0. Additionally, logical databases are not ubiquitous across tools and frameworks.  Many tools and frameworks assume database 0 is used.

Redis key structure is up to the team to decide, but it is important to stick to a convention. The following is an example of a typical convention used in the redis community.
* eg: user:id:followers
	* "user:1000:followers"
		* user: object name
		* 1000: unique identifier or the instance
		* followers: composed object


# Commands
* **KEYS**: return a list of existing key names in the database.
	* find all customer keys that begin with 1: keys customer:1*
* **SCAN**: return a list of existing key names in the database.
	* syntax: SCAN slot \[MATCH pattern\] \[COUNT count\] (\[optional\])
	* SCAN 0 MATCH customer:1*
	* Scan will return a cursor value of 0 when there is no more keys to iterate over.
* **DEL:** will remove the key and the memory associated with the key. it is performed as a blocking operation.
* **UNLINK:** The key is unlinked and will no longer exist. The memory associated with the key value is reclaimed by an asynchronous process. It is a non-blocking command.
	* UNLINK customer:1000 (will return the number of keys removed)
* **EXISTS**: check if a given key already exists
	* EXISTS customer:1000
	* Will return 0 if key does not exist and 1 if it does.

![[keys-vs-scan.png]]



